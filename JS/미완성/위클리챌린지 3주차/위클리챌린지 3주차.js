function solution(game_board, table) {
  let emptyArr = [];
  for (let i = 0; i < game_board.length; i++) {
    for (let k = 0; k < game_board.length; k++) {
      console.log(i, k);
      if (game_board[i][k] === 0) {
        game_board[i][k] = 1;
        i++;
        k--;
      }
    }
  }
  //한줄씩 검색
  //빈칸이 있다면 탐색 시작(왼쪽에서부터 오른쪽으로)
  //그 좌표는 1로 채우고, 시작점을 기준으로 좌표들을 설정하여 넣음.
  //위->아래, 왼쪽->오른쪽, 오른쪽->왼쪽, 아래->위 4방향을 모두 다 탐색
  //table에서 탐색 시작(여긴 한방향만)
  //length가 같은 배열을 서로 비교하여 맞으면 table에서의 배열을 삭제.
  //삭제한 배열의 길이를 저장.

  /*
  [0,0]
  [0,-1]
  [-1,-1]
  [1,-1]


  [1,1]
  [1,0]
  [0,0]
  [2,0]

 y=x에 대해 대칭시킴
 [1,1]
 [0,1]
 [0,0]
 [0,2]

 y축에 대해 대칭
 [-1,1]
 [0,1]
 [0,0]
 [0,2]

 - 0까지 더함
 [0,1]
 [1,1]
 [1,0]
 [1,2]

join으로 돌려서 개수가 같고 모든 요소가 포함된다면 개수를 정답에 포함.
근데 식이 너무긴듯...
안되면 다시 저 대칭식 이용
4번 다 돌려서도 안되면 때려침.


  [0,0]
  [0,-1]
  [-1,-1]
  [0,-2]

  [1,2]
  [1,1]
  [0,1]
  [1,0]


  */

  var answer = -1;
  return answer;
}
document.write(
  solution(
    [
      [1, 1, 0, 0, 1, 0],
      [0, 0, 1, 0, 1, 0],
      [0, 1, 1, 0, 0, 1],
      [1, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 1, 0],
      [0, 1, 1, 1, 0, 0],
    ],
    [
      [1, 0, 0, 1, 1, 0],
      [1, 0, 1, 0, 1, 0],
      [0, 1, 1, 0, 1, 1],
      [0, 0, 1, 0, 0, 0],
      [1, 1, 0, 1, 1, 0],
      [0, 1, 0, 0, 0, 0],
    ]
  )
);
